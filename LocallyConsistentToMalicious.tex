\section{Locally Consistent Security to Malicious Security}\label{sec:LocalToFull}

\newcommand{\VRFGen}{\mathsf{VRF.Gen}}
\newcommand{\VRFEval}{\mathsf{VRF.Eval}}
\newcommand{\VRFVerify}{\mathsf{VRF.Verify}}
\newcommand{\Expt}{\ensuremath{\mathsf{Expt}}\xspace}
\newcommand{\ExptVRF}{\ensuremath{\Expt^\mathsf{VRF}}\xspace}
\newcommand{\Oeval}{\ensuremath{\mathcal{O}_\mathsf{eval}}\xspace}

\newcommand{\Fzk}{\ensuremath{\mathcal{F}_\mathsf{zk}}\xspace}

\newcommand{\DSGen}{\mathsf{DS.Gen}}
\newcommand{\DSSign}{\mathsf{DS.Sign}}
\newcommand{\DSVerify}{\mathsf{DS.Verify}}

\newcommand{\dssk}{\mathsf{sk}^{\mathsf{ds}}}
\newcommand{\dsvk}{\mathsf{vk}^{\mathsf{ds}}}
\newcommand{\vrfsk}{\mathsf{sk}^{\mathsf{vrf}}}
\newcommand{\vrfvk}{\mathsf{vk}^{\mathsf{vrf}}}

\newcommand{\setup}{\mathsf{setup}}
\newcommand{\comp}{\mathsf{Comp}}
\newcommand{\comppc}{\comp_\mathsf{PC}}


%\Inote{overall, all treatment is not formal enough. I added some comments and made some changes but I only addressed the main one. Think of Oded, or at least about Yehuda, when writing}

In this section, we formally state and prove \cref{thm:local_to_malicious} and show how to \emph{compile} any BA protocol that is secure against locally consistent adversaries into a protocol that is secure against malicious adversaries.
That is we prove the following theorem:

\begin{theorem}[Locally consistent to malicious security, folklore, informal]\label{thm:local_to_malicious:Res}
Let $\Pi$ be a $(t,\alpha,\beta,q,\gamma)$-\BA against locally consistent adversaries and assume the existence of verifiable random functions and digital signatures.
Then, 
\begin{enumerate}
    \item
    There exists a \ppt protocol-compiler $\comp(\cdot)$ such that $\Pi'=\comp(\Pi)$ is a $(t,\alpha-\negl(\secParam),\beta-\negl(\secParam),c\cdot q,\gamma-\negl(\secParam))$-\BA in the PKI model against malicious adversaries, for a constant $c\in\N$.
    \item
    There exists a \ppt protocol-compiler $\comppc(\cdot)$ such that if $\Pi$ is a public-coin protocol, then $\Pi'=\comppc(\Pi)$ is a $(t,\alpha-\negl(\secParam),\beta-\negl(\secParam),q,\gamma-\negl(\secParam))$-\BA in the PKI model against malicious adversaries.
\end{enumerate}
\end{theorem}

In \cref{sec:ltf:prelim}, we define the cryptographic primitives used in the compiler, and in \cref{sec:ltf:compiler}, we construct the compiler and prove its security.
%\Inote{Shortly explain the structure of the section}

\subsection{Preliminaries}\label{sec:ltf:prelim}
The compiler makes use of  \emph{verifiable random functions} (VRF) \Inote{vPRF?}~\cite{MRV99} and \emph{digital signatures}  \Inote{and ZK proof of knowledge ...} defined below.

\subsubsection{Verifiable Random Functions}
We follow the definition of VRF from \cite{HJ16}.
\begin{definition}[VRF]\label{def:vrf}
A \textsf{verifiable random function} is a tuple of polynomial-time algorithms $\Pi=(\VRFGen,\VRFEval,\VRFVerify)$ of the following form.
\begin{itemize}
    \item
    $\VRFGen(1^\secParam)\to(\sk,\vk)$. On input the security parameter, the key-generation algorithm outputs a secret key $\sk$ and a public verification key $\vk$.
    \item
    $\VRFEval(\sk,x)\to(y,\pi)$. On input the secret key and an input $x\in\zo^\secParam$, the evaluation algorithm outputs a value $y\in S$ (for a finite set $S$) \Inote{change to $\cS$ all over} and a proof $\pi$.
    \item
    $\VRFVerify(\vk,x,y,\pi)\to b$. On input the verification key, an input $x\in\zo^\secParam$, an output $y\in S$, and a proof $\pi$, the deterministic verification algorithm outputs a bit $b\in\zo$.
\end{itemize}
\end{definition}
\noindent
We require the following properties:
\begin{itemize}

\item \textbf{Correctness.}
For $(\sk,\vk)\gets\VRFGen(1^\secParam)$ and $x\in\zo^\secParam$ it holds that if $(y,\pi)\gets\VRFEval(\sk,x)$ then $\VRFVerify(\vk,x,y,\pi)=1$.

\item \textbf{Unique provability.}
For all strings $(\sk, \vk)$ (not necessarily generated by $\VRFGen$) and all $x\in\zo^\secParam$, there  exists no $(y_0,\pi_0,y_1,\pi_1)$ such that $y_0\neq y_1$ and $\VRFVerify(\vk,x,y_0,\pi_0)=\VRFVerify(\vk,x,y_1,\pi_1)=1$.

\item \textbf{Pseudorandomness.}
For any \ppt adversary $\Adv=(\Adv_1,\Adv_2)$ it holds that
\[
\size{\pr{\ExptVRF_{\Pi,\Adv}(\secParam)=1}-\frac12}\leq \negl(\secParam),
\]
\noindent
for the experiment $\ExptVRF$ defined below:
\end{itemize}

\begin{small}
\begin{center}
\begin{tabular}{|l|l|}
    \hline
    \Centerstack{
    $\ExptVRF_{\Pi,\Adv}(\secParam)$
    }
    &
    \Centerstack{
    $\Oeval(x)$
    }\\
    \hline
    \Centerstack[l]{
    $(\sk,\vk)\gets\VRFGen(1^\secParam)$\\
    $(\xs,\state)\gets\Adv_1^{\Oeval(\cdot)}(\vk)$\\
    $(y_0,\pi)\gets\VRFEval(\sk,\xs)$\\
    $y_1\gets_R S$\\
    $b\gets_R \zo$\\
    $b'\gets\Adv_2^{\Oeval(\cdot)}(\state,y_b)$\\
    return $1$ if and only if $b=b'$\\
    \quad and $\Adv$ didn't query $\xs$
    }
    &
    \shortstack[l]{
    $(y,\pi)\gets\VRFEval(\sk,x)$\\
    return $(y,\pi)$
    }\\
    \hline
\end{tabular}
\end{center}
\end{small}

\subsubsection{Digital Signatures}
We consider the standard notion of existentially unforgeable signatures under an adaptive chosen-message attack~\cite{GMR88}. \Inote{please use def environment as u use above for vPRF}Such a signature scheme consists of three algorithms: a \textsf{key-generation} algorithm $\DSGen(1^\secParam)\to(\sk,\vk)$ that outputs a signing key and a verification key; a \textsf{signing} algorithm $\DSSign(\sk,m)\to\sigma$ that on input the signing key and a message outputs a signature; and a \textsf{verification} algorithm $\DSVerify(\vk,m,\sigma)\to b$ that on input the verification key, a message, and a signature, outputs a bit $b\in\zo$. We require correctness, \ie that for $\sigma\gets\DSSign(\sk,m)$ it holds that $\DSVerify(\vk,m,\sigma)=1$. In addition, we require that no \ppt adversary that can receive a polynomial number of signature on messages of its choice (under the same signing key) can generate an accepting signature on a message that has not been queried with more than negligible probability.

\subsubsection{Next-Message Functions}
An $n$-party protocol is represented by the set $\sset{\nextmsg_i}_{i\in[n]}$ of next-message functions.
The view of a party $\Party_i$ in the \rth round, denoted $\view_i^r$, consists of: her input bit $x_i$, her setup information $\setup_i$, her random coin tosses $\rho_i=(\rho_i^1,\ldots,\rho_i^r)$ (where $\rho_i^{r'}$ are the tossed coins for round $r'$) and the incoming messages $(m^{r'}_{1\to i}, \ldots, m^{r'}_{n\to i})$ for every $r'<r$, where $m^{r'}_{j\to i}$ is the message received from $\Party_j$ in round $r'$.
Given $\Party_i$'s view in the \rth round, the function $\nextmsg_i(\view_i^r)$ outputs either a list of $n$ messages $(m^r_{i\to 1}, \ldots, m^r_{i\to n})$, where $m^r_{i\to j}$ is the message to be sent by $\Party_i$ to $\Party_j$, or an output value $y$.

\subsubsection{Zero-Knowledge Proofs of Knowledge}
ZK proofs are two-party protocols that allow a prover to prove to a verifier that she knows a secret witness to a common statement, without disclosing any additional information.
We consider zero-knowledge proofs of knowledge (ZKPoK)~\cite{GMR85}, modeled as an ideal functionality $\Fzk$ that is parametrized by an NP relation $R$, and upon receiving a pair $(x,w)$ from the prover, sends to the verifier $(x,1)$ if $(x,w)\in R$ and $(x,0)$ otherwise. Such an ideal functionality can be later instantiated by any constant-round, bounded-concurrent ZKPoK protocol, \eg from \cite{Pass04}. We refer the reader to~\cite{Canetti01,Goldreich04} for more information on ideal functionalities and composition theorems.


\subsubsection{The PKI Model}
\inote{TODO: define the model and in particular, what does it mean to be secure in this model }

\subsection{The Compiler}\label{sec:ltf:compiler}

\Inote{add some introductionary text}

\Inote{Fix the protocol the VRF etc}

\paragraph{The Relation $R$.}


We will consider the following NP relations, where for $i,j\in[n]$ and an integer $r$, the relation $R^r_{i\to j}$ is defined as follows.
The instance consists of:
\begin{itemize}
	\item
	A VRF verification key $\vrfvk_i$.
	\item
	A vector of signature verification keys $(\dsvk_1,\ldots,\dsvk_n)$.
	\item
	A vector of triplets $((m_{i\to j}^1,\sigma_{i\to j}^1,\pi_i^1),\ldots,(m_{i\to j}^r,\sigma_{i\to j}^r,\pi_j^r))$ (the messages from $\Party_i$ to $\Party_j$).
\end{itemize}
The witness consists of:
\begin{itemize}
	\item
	A bit $x_i\in\zo$ and a string $\setup_i$.
	\item
	A vector of random coins $(\rho_i^1,\ldots,\rho_i^r)$.
	\item
	For every $r'\in[r]$, a vector $((m^{r'}_{1\to i},\sigma^{r'}_{1\to i},\pi^{r'}_1),\ldots,(m^{r'}_{n\to i},\sigma^{r'}_{n\to i},\pi^{r'}_n))$ ($\Party_i$'s incoming messages).
\end{itemize}
The instance/witness pair is in the relation $R^r_{i\to j}$ if the following holds:
\begin{enumerate}
	\item
	For $r'\in[r]$ it holds that $\VRFVerify(\vrfvk_i,(i,r'),\rho_i^{r'},\pi_i^{r'})=1$.
	\item
	For $r'\in[r]$ and $k\in[n]$ it holds that $\DSVerify(\dsvk_k,m^{r'}_{k\to i},\sigma^{r'}_{k\to i})=1$.
	\item
	Set $\view_i^1=(x_i,\setup_i,\rho_i^1)$ and for $1<r'\leq r$ set $\view_i^{r'}=(\view_i^{r'-1},m_{1\to i}^{r'-1},\ldots,m_{n\to i}^{r'-1},\rho_i^{r'})$. Then, for $r'\in[r]$, the \jth coordinate of $\nextmsg_i(\view_i^{r'})$ equals $m_{i\to j}^{r'}$.
\end{enumerate}








 \paragraph{The compiled protocol.}~

 \Inote{add some introductionary text}


 \Inote{Move to prelim:
 	The compiler is defined in the PKI model \Inote{the new protocol is designed to work in ...}, where a trusted party computes, for $i\in[n]$, VRF keys $(\vrfsk_i,\vrfvk_i)\gets\VRFGen(1^\secParam)$ and signature keys $(\dssk_i,\dsvk_i)\gets\DSGen(1^\secParam)$, and distributes to each party the secret keys $(\vrfsk_i,\dssk_i)$ as well as $(\vrfvk_1,\ldots,\vrfvk_n)$ and $(\dsvk_1,\ldots,\dsvk_n)$.}



 \Inote{I would not mention the  ZK-pOK hybrid model (it is a clear overkill and needs formal def i). Rather, say, let $\Delta$ be a ZK-pOK  protocol for  relation $Z$, and in the theorem assume $\Delta$ is ``secure''}
 \begin{protocol}[Protocol $\Pi' = (\Party'_1,\ldots, \Party'_n)$ \Inote{$n$?}]~

    \item[Setup:] Party $\Party'_i$ receives a setup   string $\setup_i $.  \Inote{Given by the PKI infrastructure}

    \item[Input:] Party $\Party_i'$  starts with an input bit $x_i\in\zo$.

    \Inote{do we need ZK for also for public-coin  protocols? if not, address it explicitly}

    \item[Round $r=1$:]   ~

    \begin{enumerate}
    	\item  Party $\Party_i'$ computes $(\rho_i^1,\pi_i^1)\gets\VRFEval(\vrfsk_i,(i,1))$ and sets $\view_i^1=(x_i,\setup_i,\rho_i^1)$.
    	\item $\Party_i'$ computes $(m^1_{i\to 1}, \ldots, m^1_{i\to n})=\nextmsg_i(\view_i^1)$ and signs $\sigma_{i\to j}^1\gets\DSSign(\dssk_i,m_{i\to j}^1)$ for every $j\in[n]$.
    	
    	\item $\Party_i'$ sends $(m_{i\to j}^1,\sigma_{i\to j}^1,\pi_i^1)$ to $\Party_j$ and proves consistency, \ie sends the instance $(\vrfvk_i,(\dsvk_1,\ldots,\dsvk_n),(m_{i\to j}^1,\sigma_{i\to j}^1,\pi_j^1))$ and the witness $(x_i,\setup_i,\rho^1_i)$ to $\Fzk$ parametrized by the relation $R_{i\to j}^1$.
    \end{enumerate}



    \item[Round $r>1$:]
    Let $(m_{j\to i}^{r-1},\sigma_{j\to i}^{r-1},\pi_j^{r-1})$ be the message party $\Party_i'$ received from $\Party_j$ in round $r-1$. If $\Party_j$ did not send a message, or if the ZK proof is not valid (via $\Fzk$), set $m_{j\to i}^{r-1}=\bot$.

     \begin{enumerate}
     	\item $\Party_i'$ computes $(\rho_i^r,\pi_i^r)\gets\VRFEval(\vrfsk_i,(i,r))$, sets $\view_i^r=(\view_i^{r-1},m_{1\to i}^{r-1},\ldots,m_{n\to i}^{r-1},\rho_i^r)$, computes $(m^r_{i\to 1}, \ldots, m^r_{i\to n})=\nextmsg_i(\view_i^r)$, and signs $\sigma_{i\to j}^r\gets\DSSign(\dssk_i,m_{i\to j}^r)$ for every $j\in[n]$.
     	
     	\item  $\Party_i'$ sends $(m_{i\to j}^r,\sigma_{i\to j}^r,\pi_i^r)$ to $\Party_j$ and proves consistency, \ie sends the instance $(\vrfvk_i,(\dsvk_1,\ldots,\dsvk_n),((m_{i\to j}^1,\sigma_{i\to j}^1,\pi_i^1),\ldots,(m_{i\to j}^r,\sigma_{i\to j}^r,\pi_i^r)))$ and the witness $(x_i,\setup_i,(\rho_i^1,\ldots,\rho_i^r))$ and $((m^{r'}_{1\to i},\sigma^{r'}_{1\to i},\pi^{r'}_1),\ldots,(m^{r'}_{n\to i},\sigma^{r'}_{n\to i},\pi^{r'}_n))$ for every $r'\in[r]$, to $\Fzk$ parametrized by the relation $R_{i\to j}^r$.

 \end{enumerate}
     	


    \item[Output:]    If in some round $r$, the output of $\nextmsg_i(\view_i^r)$ is a bit $y\in\zo$, then $\Party_i'$ outputs $y$ and halts. \Inote{?}
\end{protocol}

\subsubsection{Security Proof}
\Inote{add some introductionary text}


\begin{lemma}\label{lem:local_to_malicious}
Let $\Pi$ be a $(t,\alpha,\beta,q,\gamma)$-\BA against locally consistent adversaries. and let $\Pi'$ be the output of \cref{?} on $\Pi$ \Inote{make formal}.

 Then, protocol $\Pi'$ is a $\left(t,\alpha-\negl(\secParam),\beta-\negl(\secParam),q,\gamma-\negl(\secParam)\right)$-\BA against malicious adversaries in the PKI (for VRF and signatures) \Inote{which? unclear}, ZK-hybrid \Inote{POK?} model \Inote{better not use. See my comment before}.
\end{lemma}
\begin{proof}
We prove the lemma in two steps.
Initially, we consider a variant of $\Pi$, denoted $\Pi_1$, with a PKI for VRF, \ie where every party $\Party_i'$ receives $\vrfsk_i$ and $(\vrfvk_1,\ldots,\vrfvk_n)$ for $(\vrfsk_i,\vrfvk_i)\gets\VRFGen(1^\secParam)$. During the execution of the protocol, each party $\Party_i'$ evaluates $(\rho_i^r,\pi_i^r)\gets\VRFEval(\vrfsk_i,(i,r))$, sets its coins for the \rth round to $\rho_i^r$ (instead of a uniformly distributed string), and appends $\pi_i^r$ to its \rth round messages.
Clearly, by the pseudorandomness of the VRF scheme, $\Pi_1$ offers the same guarantees as $\Pi$ except for negligible probability.

Next, let $\Adv'$ be a malicious adversary attacking $\Pi'$. We will construct a locally consistent adversary $\Adv$ for the protocol $\Pi_1$. The adversary $\Adv$ starts by invoking $\Adv'$ and simulating the PKI and the setup phase, and sets the input of every corrupted party $x_i$.
\begin{itemize}
\item
Whenever $\Adv$ receives a message $(m^r_{i \to j},\pi_i^r)$ from an honest party $\Party_i'$ to a corrupted $\Party_j$, he signs the message as $\sigma_{i\to j}^r\gets\DSSign(\dssk_i,m^r_{i \to j})$, sends $(m^r_{i \to j},\sigma^r_{i \to j},\pi_i^r)$ to $\Adv'$, and simulates $\Fzk$ confirming the instance $(\vrfvk_i,(\dsvk_1,\ldots,\dsvk_n),((m_{i\to j}^1,\sigma_{i\to j}^1,\pi_i^1),\ldots,(m_{i\to j}^r,\sigma_{i\to j}^r,\pi_i^r)))$ for the relation $R^r_{i\to j}$.
\item
Whenever $\Adv$ receives $(m^r_{i \to j},\sigma^r_{i \to j},\pi_i^r)$ from $\Adv'$ on behalf of a corrupted party $\Party_i'$ to an honest $\Party_j$, along with the instance $(\vrfvk_i,(\dsvk_1,\ldots,\dsvk_n),((m_{i\to j}^1,\sigma_{i\to j}^1,\pi_i^1),\ldots,(m_{i\to j}^r,\sigma_{i\to j}^r,\pi_i^r)))$ and a corresponding witness $(x_i,\setup_i,(\rho_i^1,\ldots,\rho_i^r))$ and $((m^{r'}_{1\to i},\sigma^{r'}_{1\to i},\pi^{r'}_1),\ldots,(m^{r'}_{n\to i},\sigma^{r'}_{n\to i},\pi^{r'}_n))$ for every $r'\in[r]$, he first makes sure that the instance/witness pair are in the relation $R^r_{i\to j}$. If not, drop the message and abort $\Party_i'$. If so, send the message to $(m^r_{i \to j},\pi_i^r)$ to $\Party_j$.
\end{itemize}

By the guarantees of the digital signatures and the VRF, and by the definition of the relations $R^r_{i\to j}$, it holds that $\Adv$ carries out a locally consistent attack with all but negligible probability. The lemma follows by the assumption on the protocol $\Pi$.
\end{proof}


\paragraph{Proving \cref{thm:local_to_malicious:Res} }
\Inote{Formally prove the thm,  and use proof environment}
The first part of \cref{thm:local_to_malicious} follows from \cref{lem:local_to_malicious} by instantiating the ZK functionality with a constant-round bounded-concurrent ZK protocol. As discussed in the Introduction, for public-randomness protocols, the compiler can be simplified and not use the ZK functionality, by having each party $\Party_i'$ concatenate her \rth round coins $\rho_{i\to j}^r$ and all of her incoming messages from round $r-1$, \ie $((m^{r-1}_{1\to i},\sigma^{r-1}_{1\to i},\pi^{r-1}_1),\ldots,(m^{r-1}_{n\to i},\sigma^{r-1}_{n\to i},\pi^{r-1}_n))$, to her \rth round message to $\Party_j$ (including $\state_i$ to the first message). Now, the receiver $\Party_j$ can locally validate the relation $R^r_{i\to j}$ for each input (\ie for $x_i=0$ and for $x_1=1$), and verify the consistency of $\Party_i'$ without increasing the round complexity.

%% We next present a proof of \cref{thm:local_to_malicious}, but first some history \rnote{no need to write the history of VRF...} and definitions. Verifiable Random Functions (VRFs) were introduced by Micali, Rabin and Vadhan in \cite{MRV99}, who have also constructed a VRF based on the RSA assumption, although it was not efficient. Dodis and Yampolski \cite{DY05} presented an efficient VRF based on a decisional bilinear Diffie-Hellman inversion assumption. We give a definition of VRFs taken from (\cite{DY05}):
%
%\newcommand{\gen}{\text{GEN}}
%\newcommand{\pro}{\text{PROVE}}
%\newcommand{\ver}{\text{VERIFY}}
%
%%\begin{definition}[Verifiable Random Function Family] \label{def:vrf}
%%	Let $k \in \N$, $p,q,s:\N \mapsto \N$, $\upsilon(k) > 0$. $F_{(\cdot)}(\cdot): \zo^{p(k)} \mapsto \zo^{q(k)}$ is an $\upsilon$-Verifiable Random Function Family ($upsilon$-VRF) if there exists a triplet of algorithms $(\gen, \pro,\ver)$ such that $\gen(1^k) = (pk,sk)$, $\pro_{sk}(x) = (F_{sk}(x), \pi_{sk}(x))$, $\ver_{pk}(x,y,\pi) \zo$ and $\ver_{pk}(x,y,\pi) = 1$ if and only $F_{sk}(x) = y$ and $\pi$ is a proof of that statement. I.e, if the following three conditions hold:
%%	\begin{enumerate}
%%		\item $\forall (pk,sk) \in Im(\gen(1^k)), x, y_1, y_2$, if $F_{sk}(x) = y_1$ then there exists $\pi_1$ such that $\ver_{pk}(x,y_1,\pi_1) = 1$ and there does not exist $\pi_2$ such that $\ver_{pk}(x,y_2,\pi_2) = 1$.
%%		\item if $\pro_{sk}(x) = (y,\pi)$ then $\ver_{pk}(x,y,\pi) = 1$.
%%		\item No adversary executing more than $s(k)$ steps can win in the VRF game (defined below) with probability greater than $1/2 + \upsilon(k)$.
%%	\end{enumerate}
%%\end{definition}
%%
%%\rnote{the definition above is somewhat messy and I think a bit buggy, please copy a good definition from one place and cite it} \mnote{This is taken from \cite{DY05}.}
%%
%%To round out \cref{def:vrf} we give a definition of the VRF game:
%%\begin{definition}[VRF Game] \label{def:vrf_game}
%%The VRF game is defined by the following steps:
%%\begin{enumerate}
%%	\item A pair of keys $(pk,sk)$ is sampled from $\gen(1^k)$, and the adversary is given $pk$.
%%	\item The adversary is given oracle access to $\pro(\cdot)$, and it outputs a value $x$.
%%	\item Let $y_0 = F_{sk}(x), y_1 \leftarrow \zo^{q(k)}, b \leftarrow \zo$.
%%	\item The adversary is given $y_b$ along with oracle access to $\pro_{sk}(\cdot)$ and it outputs $b' \in \zo$.
%%	\item The adversary wins if and only if $b = b'$.
%%\end{enumerate}	
%%\end{definition}
%
%
%
%\newcommand{\sig}{\text{SIGN}}
%
%This completes the definition of VRFs. We will now formally define digital signature schemes:
%\begin{definition}[Signature Scheme] \label{def:sig_sch}
%For $k \in \N$ a triplet of PPTs $(\gen,\sig,\ver)$ with the following conditions
%\begin{enumerate}
%	\item $\gen(1^k) = (sk,vk) \in \zo^* \times \zo^*$.
%	\item For $m \in \zo^k$, $\sig_{sk}(m) = \sigma \in \zo^*$.
%	\item $\ver_{vk}(m,\sigma) \in \zo$.
%\end{enumerate}	
%is called a signature scheme if for all $(sk,vk) \in Supp(\gen(1^k))$, $m \in \zo^*$, then $\ver_{vk}(m,\sigma) = 1$ if and only if $\sigma \in Supp(\sig_{sk}(m))$.
%\end{definition}
%\rnote{where did you copy this definition from?} \mnote{Iftach's class. I think it's pretty standard.}
%
%We now present the notion for security for signature schemes:
%\begin{definition}[Existential Unforgeability] \label{def:eu}
%	For $\epsilon(k) > 0$ a signature scheme $(\gen,\sig,\ver)$ has $\epsilon$-existential unforgeability if for any PPT $\cA$ querying at most $p(k)$ queries, for some polynomial $p$ the following holds:
%	$$\ppr{(sk,sv) \leftarrow \gen(1^k)}{\cA^{\sig_{sk}}(1^k,v) = (m,\sigma) \text{ s.t } \ver_{vk}(m,\sigma) = 1 \land \cA \text{ did not query } m } < \epsilon(k) $$
%\end{definition}
%
%We can now state a formal version of \cref{thm:local_to_malicious}. We first point out that it is well known that given PKI (along with some intractability assumptions) one can construct both existentially unforgeable signature schemes (\cite{RSA78, Merkle89, Rabin1979} and many more) and VRFs (\cite{DY05}). \rnote{Why do we need PKI to construct signatures/VRF?} We begin with a definition.
%\newcommand{\euval}{(n-t)\cdot \epsilon(r)}
%\newcommand{\vrfval}{\frac{t\cdot r}{n-t}\cdot \upsilon}
%\newcommand{\rnd}{\Delta^{\epsilon,\upsilon}_{n,t,r}}
%
%\begin{definition}[$\rnd$]
%	In an $n$-party $t$-resilient Byzantine agreement executing for $r$ rounds where all parties have access to PKI for an $\epsilon$-EU signature scheme and an $\upsilon$-VRF we define $\rnd$ as:
%	\[
%	\rnd = \max(\euval, \vrfval)
%	\]
%\rnote{I don't understand what you want to define here... Why do we give signature oracle? We need to define the PKI for signatures and VRF}
%\mnote{Changed. defining quantity for a shorter statement}
%\end{definition}
%
%We present a compiler which receives as input a general Byzantine agreement protocol $\Pi$ which is secure against locally-consistent adversaries, along with a PKI for an existentially unforgeable digital signature scheme and a VRF and outputs $\Pi'$ which is a general Byzantine agreement protocol secure against malicious adversaries.
%
%We give a shorter description \rnote{we already have a short description in the intro, let's move directly to the theorem and proof} of the compiler that is described in \cref{sec:intro:LocalToFull}. Given a Byzantine agreement $\Pi$ which is secure against $t$ locally-consistent adversaries we can construct $\Pi'$, a Byzantine agreement which is secure against $t$ malicious adversaries, in the following way: Party $\QParty_i \in \Pi'$ simulates an execution of party $\Party_i \in \Pi$. In round $r$ it computes $\pro_{sk_i}(i,r) = (y_{i,r},\pi_{i,r}) = (F_k(i,r), \pi_k(i,r)) $ and sets $\Party_i$'s random tape to be $y$. It then simulates $\Party_i$'s execution for that round. Next, it signs and sends messages generated by $\Party_i$ in that round and adds a proof in zero knowledge that (1) it acted consistently with randomness output by the VRF, some input bit, and verified messages it received in previous rounds, and (2) that all messages sent so far in all previous rounds are consistent \wrt the same input bit, randomness and incoming messages. (in short - that it acted consistently with its view) Please advise \cref{sec:intro:LocalToFull} for further details of this proof. If at round $r$ it receives a message from $\QParty_j$ that either (1) cannot be verified as being sent by $\QParty_j$, (2) has a false zero-knowledge proof, or (3) is inconsistent with either its randomness (as proven using the VRF) and/or its view as previously proved, then it ignores this message, sets $\Party_i$'s incoming message tape from $\Party_j$ to an empty string (i.e abort) and adds $\QParty_j$ to the set $\cC_i$ of corrupt parties. In subsequent rounds it ignores (\ie treats as aborted) all parties in $\cC_i$.
%
%We can now state our theorem. We assume for the sake of simplicity that the zero-knowledge relations of \cref{sec:intro:LocalToFull} (except for the VRF proof) have perfect soundness and can be instantiated with some ideal functionality. Thus, we prove our theorem in the ZK-hybrid model, and later we can replace it with any UC ZK proof system. This prevents extra complication (as well as another error term) in $\rnd$. This term is nullified if $\Pi$ is a public randomness protocol. We will also consider digital signature schemes as well as VRFs as being executed by calls to ideal functionalities.
%
%\begin{theorem}[Locally consistent to malicious security, formal]\label{thm:local_to_malicious_formal}
%	If $\Pi$ is an $n$-party protocol which is a $(t,\alpha,\beta,r,\gamma)$-\BA resilient against locally-consistent adversaries. Assuming that there exists PKI for $\epsilon$-EU digital signature schemes and $\upsilon$-VRF, and a $c>0$ round zero-knowledge proof of knowledge as mentioned above, then there exists an $n$-party protocol $\Pi'$ which is a $(t,\psi_1 = \alpha + \rnd,\psi_2 = \beta + \rnd,r \cdot c,\gamma)$-\BA resilient against malicious adversaries. Further, if $\Pi$ is a public randomness protocol, then $\Pi'$ is a $(t,\psi_1 = \alpha + \rnd,\psi_2 = \beta + \rnd,r + d,\gamma)$-\BA, for a constant $d > 0$.
%\end{theorem}
%
%\rnote{where did you define the compiler? What is the protocol $\Pi'$?} \mnote{I defined it in the previous few paragraphs. Can make it clearer.} \rnote{in particular need to define the ZK -relation}
%We will prove \cref{thm:local_to_malicious_formal} for the general case, as the case for public-randomness protocols easily follows. \cref{thm:local_to_malicious_formal} follows from the next three claims:
%
%\begin{claim}\label{clm:locally_consistent_adversaries}
%	Any adversary in an $r$-round execution of $\Pi'$ controlling no more than $t$ parties cannot break the security of either (1) the signature scheme or (2) the VRF with probability greater than $\rnd$.
%\end{claim}
%
%\begin{claim}\label{clm:locally_consistent_view}
%	Let $\QParty_i$ be an honest party in an execution of $\Pi'$ with $\Party_i$ being the party in $\Pi$ it simulates. If an adversary controlling no more than $t$ parties in $\Pi'$ did not break the security of either (1) the signature scheme, or (2) the VRF then $\Party_i$' s view is consistent with an execution of $\Pi$ with no more than $t$ locally-consistent corrupted parties.
%\end{claim}
%
%Finally,
%
%\begin{claim}\label{clm:locally_consistent_view_joint}
%	Let $\QParty_i$ be an honest party in an execution of $\Pi'$ with $\Party_i$ being the party in $\Pi$ it simulates.
%	Let $\cP = \set{i \in [n] | \Party_i \text{ is simulated by } \textbf{honest } \text{party } \QParty_i \text{ in } \Pi' }$. Then the \emph{joint} view of all parties in $\Party_i$ such that $i \in \cP$ is consistent with an honest execution of $\Pi$, with the same input vector as that of the corresponding execution of $\Pi'$.
%\end{claim}
%
%We first prove \cref{thm:local_to_malicious_formal} using \cref{clm:locally_consistent_adversaries,clm:locally_consistent_view, clm:locally_consistent_view_joint}.
%
%\begin{proof}[Proof of \cref{thm:local_to_malicious_formal}.]
%Assume by way of contradiction that there exists an adversary $\cA$ controlling no more than $t$ parties in $\Pi'$ such that it causes the honest parties in $\Pi'$ to output disagreing values with probability greater than  $\alpha + \rnd$ (The converse for validity is symmetric and will therefore be omitted from the proof).  Let $\cT$ be the event that two honest parties interacting with $\cA$ in an execution of $\Pi'$ output differing values. By assumption we have
%\begin{align*}
% 	\pr{\cT} > \alpha + \rnd.
%\end{align*}
%Let $\cE$ be the event that $\cA$ either (1) forged an honest party's signature, or (2) broke the security of the VRF in an execution of $\Pi'$. Note that by \cref{clm:locally_consistent_adversaries}
%\begin{align*}
%	\pr{\cE} < \rnd.
%\end{align*}
%Thus,
%\begin{align*}
%	\pr{\cT \land \cE} > \alpha.
%\end{align*}
%By \cref{clm:locally_consistent_view} in an execution of $\Pi'$ in which $\cE$ did not occur, the honest parties' simulated parties see a view consistent with an execution of $\Pi$ with no more than $t$ locally-consistent adversaries. By \cref{clm:locally_consistent_view_joint} the joint view of all of these parties is consistent with an honest execution of $\Pi$. (This is important since \agr and \val both stem from consistency of joint views) Thus, since honest parties in $\Pi'$ output the same output as their simulated counterparts in an execution of $\Pi$, and the view of all simulated parties in $\Pi'$ is that of an execution in which they face no more than $t$ locally-consistent adversaries, we have that
%\begin{align*}
%\pr{\cT \land \cE} < \alpha
%\end{align*}
%leading to a contradiction.
%\end{proof}
%
%We can now prove \cref{clm:locally_consistent_adversaries,clm:locally_consistent_view, clm:locally_consistent_view_joint}. To prove \cref{clm:locally_consistent_adversaries} we prove two sub-claims.
%
%\begin{claim}\label{clm:locally_consistent_eu}
%	Let $\cE_1$ be the event that in an $r$-round execution of $\Pi'$ with adversary $\cA$ controlling no more than $t$ parties, $\cA$ managed to forge an honest party's signature. Then
%	\begin{align}\label{eq:locally_consistent_eu}
%		\pr{\cE_1} < \euval.
%	\end{align}
%\end{claim}
%
%\begin{claim}\label{clm:locally_consistent_vrf}
%	Let $\cE_2$ be the event that in an $r$-round execution of $\Pi'$ with adversary $\cA$ controlling no more than $t$ parties, $\cA$ managed to produce $\pi$, a false proof accepted by an honest party. Then
%	\begin{align}\label{eq:locally_consistent_vrf}
%	\pr{\cE_2} < \vrfval.
%	\end{align}
%\end{claim}
%
%These two claims are enough to prove \cref{clm:locally_consistent_adversaries} as we can simply note that $\cE \equiv \cE_1 \lor \cE_2$. We prove them next.
%\begin{proof}[Proof of \cref{clm:locally_consistent_eu}.]
%	Assume there exists an adversary $\cA$ for which \cref{eq:locally_consistent_eu} does not hold. Consider the following adversary $\cB$ to the signature scheme:
%	{\samepage
%		\begin{description}
%		\item[$\cB^{\sig}$.]		
%		\begin{enumerate}
%			\item Simulate an execution of $\Pi'$ with adversary $\cA$.
%			
%			\item Let $\cP_\cA$ be the set of parties adversary $\cA$ has chosen to corrupt. Sample party ${\cQ \leftarrow \cP \setminus \cP_\cA}$ uniformly at random.
%			
%			\item In each round of $\Pi'$, if $\cQ$ queries its signing oracle with $q$, then query $\sig(q)$ and respond to $\cQ$ with the result of that query. For other parties $\cB$ simply simulates a consistent view of an oracle for a signature scheme and an oracle for a VRF.
%			
%			\item If at any round $\cA$ forged a signature $\sigma$ on a message $m$ by $\cQ$ then output $(m,\sigma)$.
%			
%			\item else, output a random message $m$ and random value $\tilde{\sigma}$ from the image of \sig.
%		\end{enumerate}
%	\end{description}
%}
%
%Let $\cF$ be the event that $\cB$ forged a valid signature and let $\cG$ be the event that $\cA \text{ forged a signature by } \cQ \text{ and } \cQ \text{ was selected by } \cB$. Notice first that the simulated $\cA$'s view in $\cB$'s execution is clearly consistent with that of an $r$-round execution of $\Pi'$, as all oracle queries are answered consistently according to step (3). Thus,
%\begin{align*}
%\pr{\cF} &= \pr{\cG}\\&+ \pr{\neg \cG \land \cB \text{ randomly sampled a valid message and signature pair in step 5 }}\\
%&>\pr{\cG} \ge \pr{\cA \text{ forged a signature by } \cQ} \cdot \frac{1}{n-t} \ge \epsilon(r)
%\end{align*}
%where the final two inequalities are by $\cA$ corrupting at most $t$ parties and the assumption over $\cA$'s forging probability, respectively. Thus, $\cB$ manages to forge a signature with $r$ queries with probability greater than $\epsilon(r)$, in contradiction to the assumption over the signature scheme.
%\end{proof}
%
%\begin{proof}[Proof of \cref{clm:locally_consistent_vrf}.]
%	Assume there exists an adversary $\cA$ for which \cref{eq:locally_consistent_vrf} does not hold. Consider the following adversary $\cB$ in the role of prover $P$ in communication with verifier $V$ for the VRF.
%	{\samepage
%			\begin{description}
%		\item[$<\cB, V>$]		
%		\begin{enumerate}
%			\item Simulate an execution of $\Pi'$ with adversary $\cA$.
%			
%			\item Let $\cP_\cA$ be the set of parties adversary $\cA$ has chosen to corrupt. Sample party ${\cQ_p \leftarrow \cP_\cA}$ and party $\cQ_v \leftarrow \cP \setminus \cP_\cA$ uniformly at random. Also sample $d \leftarrow [r]$ uniformly at random.
%			
%			\item In each round of $\Pi'$ $\cB$ provides a consistent view of a signing oracle to all parties. At round $d$ it performed the following in the proving phase:
%			
%			\item Let $m, \pi^{p,v}_d$ be the message, proof pair sent from party $\cQ_p$ to party $\cQ_v$ - $\cB$ sends $m, \pi^{p,v}_d$ to $V$.
%			
%			\item $\cB$ then halts.
%		\end{enumerate}
%	\end{description}
%}
%
%Let $\cD$ be the event that $\cB$ managed to make $V$ accepts a non-valid proof. By a similar reasoning to the one in the proof of \cref{clm:locally_consistent_eu} we have our claim, as the proofs of the VRF are independent between rounds and between parties (\ie they stand on their own without context). Thus, the view of $V$ is that of an execution of the proving part of the VRF protocol with prover $\cQ_p$, and the view of $\cA$ is consistent with an execution of $\Pi'$.
%\end{proof}
%
%Finally, a proof of \cref{clm:locally_consistent_view} will give us \cref{thm:local_to_malicious_formal}.
%
%\begin{proof}[Proof of \cref{clm:locally_consistent_view}.]
%	
%	First, recall the definition of a locally-consistent adversary. A locally consistent adversary is one that can (1) abort prematurely, (2) send messages based on differing input bits and messages from honest parties, (3) sample their random coins honestly, and (4) cannot lie about messages received from honest parties. Given this, the proof of this claim is fairly simple, as in an execution of $\Pi'$ in which no adversary has forged an honest party's signature and all proofs were accepted, all honest parties have received messages consistent with other honest parties' messages in the execution, and as no adversary has managed to provide a false proof of consistency then it either was flagged as being aborted (which, again, it can do as a locally-consistent adversary) by an honest party $\cQ$ or has acted honestly \wrt its randomness. Thus, the view of parties in $\Pi$ simulated in $\Pi'$ is consistent with an execution of $\Pi$ in the presence of a locally-consistent adversary controlling no more than $t$ parties.
%\end{proof}
%
%Finally, a proof of \cref{clm:locally_consistent_view_joint} will give us \cref{thm:local_to_malicious_formal}. This proof is trivial, as the ZK proofs require every party to act consistently with all of its received messages and randomness. Since each honest party has a consistent view on its own, and all parties have proven consistency with each other, then all simulated parties' views are consistent with the \textbf{same} honest execution of $\Pi$. This gives us \cref{thm:local_to_malicious_formal}.
%	
